global:
  # -- (object) Global Docker image parameters.<br>
  # @notationType -- yaml
  # Please, note that this will override the image parameters, including dependencies, configured to use the global value.<br>
  # Current available global Docker image parameters: imageRegistry, imagePullSecrets and storageClass.
  imageRegistry: ""
  imagePullSecrets: []
  storageClass: ""

image:
  # -- Set image registry.<br>
  registry: ""
  # -- Set image repository.<br>
  repository: ""
  # -- Set image tag.<br>
  tag:
  # -- Set image fullImage. Can be used to set the complete URL.<br>
  fullImage: "" # use this from pipeline, includes registry, repo, and tag
  # -- Optionally specify an array of imagePullSecrets.<br>
  # Secrets must be manually created in the namespace.<br>
  # ref: <a href="https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/">[link]</a>
  pullSecrets: []
  pullPolicy: Always

# -- Specifies the application name (required to be set).<br>
name: "zgw-dre"
# -- Set the number of replicas.<br>
replicaCount: 1

# -- How many seconds a pod needs to be ready before killing the next, during update
minReadySeconds: 10

# -- Specifies the application resource kind.<br>
appKind: Deployment

# -- Specifies the pod labels.<br>
podLabels: {}

args: []
# -- String to partially override common.names.fullname template (will maintain the release name).<br>
nameOverride: ""
# -- String to fully override common.names.fullname template.<br>
fullnameOverride: ""
# -- Deployment pod host aliases.<br>
# ref: <a href="https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/">[link]</a>
hostAliases: []
# -- Controls whether the pod may use the node network namespace.<br>
# ref: <a href="https://kubernetes.io/docs/concepts/security/pod-security-policy/#host-namespaces">[link]</a>
hostNetwork: false

serviceAccount:
  # -- Specifies whether a service account should be created.<br>
  create: false
  # -- Annotations to add to the service account.<br>
  annotations: {}
  # -- The name of the service account to use.<br>
  # If not set and create is true, a name is generated using the fullname template.<br>
  name: ""
  # -- Controls whether the container automatically mounts the ServiceAccount's API credentials.<br>
  # In the serviceaccount/v1 this defaults to true, so also in this Helm chart. recommended: false.<br>
  # ref: <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#opt-out-of-api-credential-automounting">[link]</a>
  automountServiceAccountToken: true

# -- Add labels to all the deployed resources.<br>
commonLabels: {}
# -- Add annotations to all the deployed resources.<br>
commonAnnotations: {}
# -- Pod annotations.<br>
# ref: <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/">[link]</a>
podAnnotations: {}

# -- Init containers that run inside the pod before Camunda is started in the main container. Use this to pull DMN's from remote repositories or to copy configuration files like production.yaml.<br>
# ref: <a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/">[link]</a>
initContainers: []

priorityClassName: ""
# -- Optionally, change this to ClusterFirstWithHostNet in case you have 'hostNetwork: true'.<br>
# By default, while using host network, name resolution uses the host's DNS. If you wish nginx-controller.<br> 
# to keep resolving names inside the k8s network, use ClusterFirstWithHostNet.<br>
dnsPolicy: ClusterFirst

podSecurityContext:
  # -- (object) Pod securityContext.<br>
  # @notationType -- yaml<br>
  # ref: <a href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod">[link]</a>
  enabled: true
  fsGroup: 1000
  runAsUser: 1000
  runAsGroup: 1000
  runAsNonRoot: true

containerSecurityContext:
  # -- (object) Container security context.<br>
  # @notationType -- yaml
  # @raw
  # <details>
  # <summary>+Expand</summary>
  #
  # ```yaml
  # containerSecurityContext:
  #   capabilities:
  #     drop:
  #     - ALL
  #   readOnlyRootFilesystem: true
  #   runAsNonRoot: true
  #   runAsUser: 1000
  #   allowPrivilegeEscalation: false
  # ```
  # </details>
  # ref: <a href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container">[link]</a>
  enabled: true
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  runAsNonRoot: true
  runAsUser: 1000

containerPorts: []

service:
  # -- Kubernetes service type and port number.<br>
  type: ClusterIP
  port: 8080
  targetPort: 8080
  # -- Provide any additional service annotations.<br>
  annotations: {}
  # -- Provide any additional service labels.<br>
  labels: {}
  ports: []

sidecar: {}

updateStrategy:
  # -- (object) Set up update strategy for installation. Set to Recreate if you use persistent volume that cannot be mounted by more than one pod to ensure the pods are destroyed first.
  # @notationType -- yaml
  # @raw
  # <details>
  # <summary>+Expand</summary>
  #
  # ```yaml
  # updateStrategy:
  #  type: RollingUpdate
  #  rollingUpdate:
  #    maxSurge: 25%
  #    maxUnavailable: 25%
  # ```
  # </details>
  type: ""

# -- Ingress configuration (nginx or other controllers).<br>
ingress:
  enabled: false
  tls: false
  # -- Configuration snippet for customizing Nginx Ingress behavior.<br>
  nginx:
    configurationSnippet: ""
  # -- Ingress class (leave empty to let controller discover).<br>
  ingressClassName: ""
  # -- Base annotations for this ingress.<br>
  annotations: {}
  # -- Extra annotations (rendered via tpl).<br>
  extraAnnotations: {}
  # -- FQDN for the host.<br>
  hostname: ""
  # -- Path and pathType for the service.<br>
  path: /
  pathType: Prefix
  # -- Optional extra hosts/paths/tls blocks.<br>
  extraHosts: []
  extraPaths: []
  extraTls: []
  # -- If set, use this existing TLS secret (overrides auto-generated secret name).<br>
  existingTlsSecret: ""
  # -- Target service/port behind the ingress.<br>
  service:
    port: 8080

# -- Optional second ingress (e.g., Azure Application Gateway).<br>
extraIngress:
  enabled: false
  tls: false
  nginx:
    configurationSnippet: ""
  nameSuffix: ""
  ingressClassName: ""
  annotations: {}
  extraAnnotations: {}
  hostname: ""
  path: /*
  pathType: Prefix
  extraHosts: []
  extraPaths: []
  extraTls: []
  existingTlsSecret: ""
  service:
    port: 8080

resources:
  # -- Define the resource limits for the container.<br>
  limits:
    cpu: 0.5
    memory: 1.5Gi
  # -- Define the resource requests for the container.<br>
  requests:
    cpu: 0.5
    memory: 1Gi

autoscaling:
  # -- Enable or disable horizontal pod autoscaling (HPA).<br>
  enabled: false  # Set to `true` to enable HPA.<br>

nodeSelector: {}
tolerations: []
topologySpreadConstraints: []
podAffinityPreset: ""
podAntiAffinityPreset: soft
nodeAffinityPreset:
  type: ""
  key: ""
  values: []

affinity: {}
envFrom: []
volumes:
  # -- Array of volumes for the application.<br>
  # These volumes are mounted to enable data persistence and configuration loading.
  - name: zgw-dre-config
    configMap:
      name: zgw-dre-config
  - name: dmn-volume
    emptyDir: {}
  - name: dmndir
    emptyDir: {}
  - name: configdir
    emptyDir: {}
  - name: camunda-logs
    emptyDir: {}
  - name: camunda-work
    emptyDir: {}
  - name: tomcat-tmp-dir
    emptyDir: {}

volumeMounts:
  # -- (list) Array to add volume mounts (normally used with volumes).<br>
  - name: tomcat-tmp-dir
    mountPath: /tmp
  - name: camunda-logs
    mountPath: /camunda/logs
  - name: camunda-work
    mountPath: /camunda/work
  - name: dmn-volume
    mountPath: /temp
  - name: zgw-dre-config
    mountPath: /temp/config
  - name: dmndir
    mountPath: /camunda/configuration/resources/
  - name: configdir
    mountPath: /camunda/configuration/production.yml
    subPath: production.yml

persistence:
  enabled: false
  storageClass:
  existingClaim: ""
  accessMode: ReadWriteMany

configMaps: {}
secrets: {}
syncAKV: {}
podDisruptionBudget:
  enabled: false
  minAvailable: 1

checksums: []
extraObjects: []
tests:
  httpChecks:
    default: false

general:
  # -- Enable or disable debug mode for the application.<br>
  # Defaults to 'false' to prevent excessive logging in production.
  debug: false

env:
  # -- Array of environment variables to configure application settings.<br>
  # Customize values as needed for the target environment.
  - name: CAMUNDA_HOST_URL
    # -- URL for Camunda host.<br>
    # Example: "http://camunda.example.com"
    value: "{{ .Values.camunda.host }}"
  - name: DB_DRIVER
    # -- Database driver class name.<br>
    # Example: "org.postgresql.Driver"
    value: "{{ .Values.database.driver }}"
  - name: DB_URL
    # -- JDBC URL for connecting to the database.<br>
    # Example: "jdbc:postgresql://hostname:5432/dbname"
    value: "{{ .Values.database.url }}"
  - name: DB_USERNAME
    # -- Database username from Kubernetes secret.<br>
    valueFrom:
      secretKeyRef:
        name: "{{ .Values.database.credentialsSecretName}}"
        key: "{{ .Values.database.credentialsSecretKeys.username }}"
  - name: DB_PASSWORD
    # -- Database password from Kubernetes secret.<br>
    valueFrom:
      secretKeyRef:
        name: "{{ .Values.database.credentialsSecretName}}"
        key: "{{ .Values.database.credentialsSecretKeys.password }}"
  - name: KEYCLOAK_HOST
    # -- URL for Keycloak host.<br>
    value: "{{ .Values.keycloak.host }}"
  - name: KEYCLOAK_REALM
    # -- Keycloak realm to be used for authentication.<br>
    value: "{{ .Values.keycloak.realm }}"
  - name: KEYCLOAK_CLIENT_ID
    # -- Keycloak client ID for the application.<br>
    value: "{{ .Values.keycloak.clientId }}"
  - name: KEYCLOAK_CLIENT_SECRET
    # -- Keycloak client secret reference.<br>
    valueFrom:
      secretKeyRef:
        name: "{{ .Values.keycloak.clientSecret.name }}"
        key: "{{ .Values.keycloak.clientSecret.key }}"
  - name: PLUGIN_IDENTITY_KEYCLOAK_KEYCLOAKISSUERURL
    # -- Issuer URL for Keycloak realm.<br>
    value: "{{ .Values.keycloak.host }}/realms/{{ .Values.keycloak.realm }}"
  - name: PLUGIN_IDENTITY_KEYCLOAK_KEYCLOAKADMINURL
    # -- Admin URL for Keycloak realm.<br>
    value: "{{ .Values.keycloak.host }}/admin/realms/{{ .Values.keycloak.realm }}"
  - name: PLUGIN_IDENTITY_KEYCLOAK_CLIENTID
    # -- Client ID for Keycloak integration.<br>
    value: "{{ .Values.keycloak.clientId }}"
  - name: PLUGIN_IDENTITY_KEYCLOAK_CLIENTSECRET
    # -- Client secret reference for Keycloak.<br>
    valueFrom:
      secretKeyRef:
        name: "{{ .Values.keycloak.clientSecret.name }}"
        key: "{{ .Values.keycloak.clientSecret.key }}"
  - name: PLUGIN_IDENTITY_KEYCLOAK_USEGROUPPATHASCAMUNDAGROUPID
    # -- Use Keycloak group path as Camunda group ID.<br>
    value: "true"
  - name: PLUGIN_IDENTITY_KEYCLOAK_ADMINISTRATORGROUPNAME
    # -- Name of the administrator group in Keycloak.<br>
    value: "camunda_admin"
  - name: PLUGIN_IDENTITY_KEYCLOAK_DISABLESSLCERTIFICATEVALIDATION
    # -- Disable SSL certificate validation for Keycloak integration.<br>
    value: "false"

# -- Additional environment variables merged into 'env' in the Deployment.<br>
extraEnv: []

command:
  # -- Command to start the Camunda application.<br>
  # This is the main entrypoint command for the container.
  - './camunda.sh --production'

livenessProbe:
  # -- Enable or disable the liveness probe.<br>
  enabled: true
  # -- HTTP GET method used by liveness probe to check health.<br>
  httpGet:
    path: /engine-rest/engine
    port: 8080
  initialDelaySeconds: 60
  periodSeconds: 30
  timeoutSeconds: 5
  failureThreshold: 3
  successThreshold: 1

readinessProbe:
  # -- Enable or disable the readiness probe.<br>
  enabled: true
  # -- HTTP GET method used by readiness probe to check if the container is ready to handle traffic.<br>
  httpGet:
    path: /engine-rest/engine
    port: 8080
  initialDelaySeconds: 30
  periodSeconds: 20
  timeoutSeconds: 5
  failureThreshold: 3
  successThreshold: 1

startupProbe:
  # -- Enable or disable the startup probe.<br>
  enabled: false
  # -- HTTP GET method used by startup probe to check if the application has started.<br>
  httpGet:
    path: /engine-rest/engine
    port: 8080
  initialDelaySeconds: 30
  periodSeconds: 30
  timeoutSeconds: 5
  failureThreshold: 10
  successThreshold: 1

camunda:
  # -- Configuration for Camunda-specific settings.<br>
  host: ""

keycloak:
  # -- Configuration for Keycloak settings.<br>
  host: ""
  realm: ""
  clientId: ""
  clientSecret:
    name: ""
    key: ""

liquibase:
  # -- Configuration for liquibase settings.<br>
  changelog:
    enabled: false
  image: "liquibase/liquibase:4.30"
  job:
    ttlSecondsAfterFinished: 600

database:
  # -- Configuration for database settings.<br>
  driver: ""
  url: ""
  credentialsSecretName: ""
  credentialsSecretKeys:
    username: ""
    password: ""
